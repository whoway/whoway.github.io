(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{481:function(_,v,t){"use strict";t.r(v);var r=t(14),a=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"编译原理基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译原理基础"}},[_._v("#")]),_._v(" 编译原理基础")]),_._v(" "),v("div",{staticClass:"language-txt line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-txt"}},[v("code",[_._v('<font style="background:yellow">\n')])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("h2",{attrs:{id:"✔️开篇词-为什么你要学习编译原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️开篇词-为什么你要学习编译原理"}},[_._v("#")]),_._v(" ✔️开篇词 | 为什么你要学习编译原理？")]),_._v(" "),v("ul",[v("li",[_._v("我喜欢做平台性的软件，而编译技术就是产品取得优势的关键。")])]),_._v(" "),v("p",[_._v("很多国外厂商的软件，普遍都具备"),v("strong",[_._v("二次编程能力")]),_._v("，比如 Office、CAD、GIS、 Mathematica 等等。德国 SAP 公司的企业应用软件也是用自己的业务级语言编写的。目 前来看，谷歌也好，苹果也好，微软也好，这些技术巨头们的核心能力，都是拥有自己的语言和生态。可见编译技术有多么重要！")]),_._v(" "),v("p",[_._v("我介绍的 Antlr 和 LLVM 工具，前者能帮你做编译器前端的工作，后者能帮你完成编译器后端 的工作。在课程中，你能真正运用编译技术解决报表设计等实际问题")]),_._v(" "),v("h2",{attrs:{id:"⭐️编译器前端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️编译器前端"}},[_._v("#")]),_._v(" ⭐️编译器前端")]),_._v(" "),v("h2",{attrs:{id:"_01-理解代码-编译器的前端技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_01-理解代码-编译器的前端技术"}},[_._v("#")]),_._v(" 01.理解代码：编译器的前端技术")]),_._v(" "),v("h3",{attrs:{id:"🐾词法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#🐾词法分析"}},[_._v("#")]),_._v(" 🐾词法分析")]),_._v(" "),v("ul",[v("li",[_._v("词法分析是把程序分割成一个个 Token 的过程，可以通过构造"),v("strong",[_._v("有限自动机")]),_._v("来实现。\n"),v("ul",[v("li",[_._v("上述编译过程其实跟你的实际工作息息相关。比如，词法分析就是你工作中 "),v("strong",[_._v("使用正则表达式")]),_._v("的过程，比如grep,awk,sek")])])])]),_._v(" "),v("h3",{attrs:{id:"🐾语法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#🐾语法分析"}},[_._v("#")]),_._v(" 🐾语法分析")]),_._v(" "),v("ul",[v("li",[_._v("语法分析是把程序的结构识别出来，并形成一棵便于由计算机处理的抽象语法树。可以用 "),v("strong",[_._v("递归下降的算法")]),_._v("来实现。\n"),v("ul",[v("li",[_._v("而语法分析在你解析文本文件、配置文件、模型定义文件，或者做 "),v("strong",[_._v("自定义公式功能")]),_._v("的时候都会用到。")])])])]),_._v(" "),v("h3",{attrs:{id:"🐾语义分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#🐾语义分析"}},[_._v("#")]),_._v(" 🐾语义分析")]),_._v(" "),v("ul",[v("li",[_._v("语义分析是"),v("strong",[_._v("消除语义模糊")]),_._v("，生成一些属性信息，让计算机能够依据这些信息生成目标代 码。")])]),_._v(" "),v("h3",{attrs:{id:"_1-1-前端-中端-后端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-前端-中端-后端"}},[_._v("#")]),_._v(" 1.1.前端-中端-后端")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%AB%AF%E5%90%8E%E7%AB%AF.jpg",alt:"编译器的前端中端后端"}})]),_._v(" "),v("ul",[v("li",[_._v("分享了一些使用编译技术的场景。其中"),v("strong",[_._v("有的场景")]),_._v("，你"),v("strong",[_._v("只要掌握编译器的前端技术")]),_._v("就能解决。比如文本分析场景，软件需要用户自定义功能的场景以及前端编程语言的翻译场景等。")]),_._v(" "),v("li",[_._v("而且咱们"),v("font",{staticStyle:{background:"yellow"}},[v("strong",[_._v("大学讲的编译原理")])]),_._v("，也是"),v("strong",[_._v("侧重讲解前端技术")]),_._v("，可见编译器的前端技术有多么重要。")],1)]),_._v(" "),v("p",[_._v("**“前端”指的是编译器对程序代码的分析和理解过程。**它通常只跟语言的语法有关，跟目标机器无关")]),_._v(" "),v("p",[v("strong",[_._v("后端”则是生成目标代码的过程，跟目标机器有关")])]),_._v(" "),v("h2",{attrs:{id:"_02-正则文法和有限自动机-纯手工打造词法分析器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_02-正则文法和有限自动机-纯手工打造词法分析器"}},[_._v("#")]),_._v(" 02 | 正则文法和有限自动机：纯手工打造词法分析器")]),_._v(" "),v("ul",[v("li",[_._v("提到词法分析的工作是将一个长长的字符串识别出一个个的单词，这一个个单词就是 "),v("strong",[_._v("Token")]),_._v("。而且词法分析的工作是"),v("strong",[_._v("一边读取一边识别字符串")]),_._v("的，不是把字符串都读到内存再识别。你在听一位朋友讲话的时候，其实也是同样的过程，一边听，一边提取信息")])]),_._v(" "),v("h2",{attrs:{id:"_03丨语法分析-一-纯手工打造公式计算器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_03丨语法分析-一-纯手工打造公式计算器"}},[_._v("#")]),_._v(" 03丨语法分析（一）：纯手工打造公式计算器")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("语法分析的原理")]),_._v("和"),v("strong",[_._v("递归下降算法（Recursive Descent Parsing），并初步了解上下文无关文法（Context-free Grammar，CFG）")])])]),_._v(" "),v("h3",{attrs:{id:"_3-1-上下文无关文法和正则文法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-上下文无关文法和正则文法"}},[_._v("#")]),_._v(" 3.1.上下文无关文法和正则文法")]),_._v(" "),v("ul",[v("li",[_._v("正则文法是"),v("strong",[_._v("上下文无关文法")]),_._v("的一个"),v("strong",[_._v("子集")]),_._v(" "),v("ul",[v("li",[_._v("区别呢，就是上下文无关文法"),v("strong",[_._v("允许")]),_._v("递归调用，而正则文法"),v("strong",[_._v("不允许")]),_._v("。")])])]),_._v(" "),v("li",[_._v("上下文无关的意思是，无论在任何情况下，文法的推导规则都是一样的。\n"),v("ul",[v("li",[_._v("好在你见到的"),v("strong",[_._v("大多数")]),_._v("计算机语言，都能用上下文无关文法来表达它的语法。")])])]),_._v(" "),v("li",[_._v("那有没有"),v("strong",[_._v("上下文相关")]),_._v("的情况需要处理呢？也是有的，但那"),v("strong",[_._v("不是")]),_._v("语"),v("strong",[_._v("法")]),_._v("分析阶段负责的，而是放在"),v("strong",[_._v("语义")]),_._v("分析阶段来处理的。")])]),_._v(" "),v("h3",{attrs:{id:"_3-2-「文法的递归调用」和「算法的递归调用」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-「文法的递归调用」和「算法的递归调用」"}},[_._v("#")]),_._v(" 3.2.「文法的递归调用」和「算法的递归调用」")]),_._v(" "),v("p",[_._v("在讲解上下文无关文法时，我提到了文法的递归调用，你也许会问，是否在算法上也需要递归的调用呢？要不怎么叫做“递归下降算法”呢？")]),_._v(" "),v("ul",[v("li",[_._v("的确，我们之前的算法只算是用到了“下降”，没有涉及“递归”，现在，我们就来看看如何用"),v("strong",[_._v("递归的算法")]),_._v("翻译"),v("strong",[_._v("递归的文法")]),_._v("。")]),_._v(" "),v("li",[_._v("但是，我们遇到麻烦了。这个麻烦就是"),v("strong",[_._v("出现了无穷多次调用")]),_._v("的情况\n"),v("ul",[v("li",[_._v("“2+3”这个文法规则的"),v("strong",[_._v("第一部分就递归地引用了自身")]),_._v("，这种情况叫做**左递归。**通过上面的分析，我们知道左递归是递归下降算法无法处理的，这是递归下降算法最大的问题。")])])])]),_._v(" "),v("h2",{attrs:{id:"_04-语法分析-二-解决二元表达式中的难点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_04-语法分析-二-解决二元表达式中的难点"}},[_._v("#")]),_._v(" 04 | 语法分析（二）：解决二元表达式中的难点")]),_._v(" "),v("ul",[v("li",[_._v("左递归（Left Recursive）、优先级（Priority）和结合性（Associativity）。")]),_._v(" "),v("li",[_._v("我们要想深入探讨语法规则设计，需要像在词法分析环节一样，先了解如何用"),v("strong",[_._v("形式化")]),_._v("的方法表达语法规则。“工欲善其事必先利其器”。"),v("strong",[_._v("熟练")]),_._v("地阅读和书写语法规则，是我们在语法分析环节需要掌握的一项基本功。")])]),_._v(" "),v("h3",{attrs:{id:"_4-1-书写语法规则-并进行推导"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-书写语法规则-并进行推导"}},[_._v("#")]),_._v(" 4.1.书写语法规则，并进行推导")]),_._v(" "),v("p",[_._v("我们已经知道，语法规则是由上下文无关文法表示的，而上下文无关文法是由一组替换规则（又叫产生式）组成的")]),_._v(" "),v("p",[_._v("在实际应用中，语法规则经常写成下面这种形式：")]),_._v(" "),v("div",{staticClass:"language-bnf line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bnf"}},[v("code",[_._v("add "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("::=")]),_._v(" mul "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" add "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),_._v(" mul\nmul "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("::=")]),_._v(" pri "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" mul "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" pri\npri "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("::=")]),_._v(" Id "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" Num "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("(")]),_._v("add"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v(")")]),_._v(" \n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("ul",[v("li",[_._v("这种写法叫做**“巴科斯范式”，**简称 BNF。"),v("strong",[_._v("Antlr 和 Yacc 这两个工具都用这种写法")]),_._v("。为了简化书写，我有时会在课程中把“::=”简化成一个冒号。你看到的时候，知道是什么意思就可以了。")]),_._v(" "),v("li",[_._v("你有时还会听到一个术语，叫做**扩展巴科斯范式 (EBNF)。**它跟普通的 BNF 表达式最大的区别，就是里面会用到类似正则表达式的一些写法。比如下面这个规则中运用了 * 号，来表示这个部分可以重复 0 到多次：")])]),_._v(" "),v("div",{staticClass:"language-bnf line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bnf"}},[v("code",[_._v("add -> mul "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),_._v(" mul"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("ul",[v("li",[_._v("其实这种写法跟标准的 BNF 写法是等价的，但是更"),v("strong",[_._v("简洁")]),_._v("。为什么是等价的呢？"),v("strong",[_._v("因为一个项多次重复，就等价于通过递归来推导")]),_._v("。从这里我们还可以得到一个推论：就是上下文无关文法包含了正则文法，比正则文法能做更多的事情。")])]),_._v(" "),v("h3",{attrs:{id:"消除左递归"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消除左递归"}},[_._v("#")]),_._v(" 消除左递归")]),_._v(" "),v("ul",[v("li",[_._v("并不是所有的算法都不能处理左递归，对于另外一些算法，"),v("strong",[_._v("左递归是没有问题的，比如 LR 算法")]),_._v("。")]),_._v(" "),v("li",[_._v("消除左递归，用一个标准的方法，就能够把左递归文法改写成非左递归的文法")])]),_._v(" "),v("h3",{attrs:{id:"尾递归"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#尾递归"}},[_._v("#")]),_._v(" "),v("strong",[_._v("尾递归")])]),_._v(" "),v("ul",[v("li",[_._v("在研究递归函数的时候，有一个概念叫做**尾递归，**尾递归函数的最后一句是递归地调用自身。")]),_._v(" "),v("li",[_._v("编译程序通常都会把尾递归转化为一个循环语句，使用的原理跟上面的伪代码是一样的")]),_._v(" "),v("li",[_._v("因此，把"),v("strong",[_._v("尾递归转化为循环语句也是一种编译优化")]),_._v("技术。")])]),_._v(" "),v("h4",{attrs:{id:"左递归问题是我们用递归下降算法写语法分析器遇到的最大的一只-拦路虎-。解决这只-拦路虎-以后-你的道路将会越来越平坦"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左递归问题是我们用递归下降算法写语法分析器遇到的最大的一只-拦路虎-。解决这只-拦路虎-以后-你的道路将会越来越平坦"}},[_._v("#")]),_._v(" 左递归问题是我们用递归下降算法写语法分析器遇到的最大的一只“拦路虎”。解决这只“拦路虎”以后，你的道路将会越来越平坦")]),_._v(" "),v("h2",{attrs:{id:"_05-语法分析-三-实现一门简单的脚本语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_05-语法分析-三-实现一门简单的脚本语言"}},[_._v("#")]),_._v(" 05 | 语法分析（三）：实现一门简单的脚本语言")]),_._v(" "),v("h3",{attrs:{id:"实现一个简单的-repl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现一个简单的-repl"}},[_._v("#")]),_._v(" 实现一个简单的 REPL")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("脚本语言")]),_._v("一般都会提供一个"),v("strong",[_._v("命令行窗口")]),_._v("，让你输入一条一条的语句，"),v("strong",[_._v("马上解释执行它")]),_._v("，并得 到输出结果，比如 Node.js、Python 等都提供了这样的界面。这个输入、执行、打印的循环过程就叫做 REPL（Read-Eval-Print Loop）。")]),_._v(" "),v("li",[_._v("学完这讲以后，你也能找到了一点感觉：Shell 脚本也好，PHP 也好，JavaScript 也好， Python 也好，其实都可以这样写出来。")]),_._v(" "),v("li",[_._v("回顾过去几讲，你已经可以分析词法、语法、进行计算，还解决了左递归、优先级、结合性 的问题。甚至，你还能处理语法错误，让脚本解释器不会因为输入错误而崩溃。")])]),_._v(" "),v("h2",{attrs:{id:"_06-编译器前端工具-一-用antlr生成词法、语法分析器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_06-编译器前端工具-一-用antlr生成词法、语法分析器"}},[_._v("#")]),_._v(" 06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210909162405.png",alt:"image-20210909162405522"}})]),_._v(" "),v("ul",[v("li",[_._v("如果让编译程序实现上面这么多工作，完全手写效率会有点儿低，那么我们有什么方法可以提升效率呢？答案是借助工具。")]),_._v(" "),v("li",[_._v("编译器前端工具有很多，比如\n"),v("ul",[v("li",[_._v("Lex（以及 GNU 的版本 Flex）")]),_._v(" "),v("li",[_._v("Yacc（以及 GNU 的版本 Bison）")]),_._v(" "),v("li",[_._v("JavaCC 等等。")])])]),_._v(" "),v("li",[_._v("你可能会问了：“那为什么我们这节课只讲 Antlr，不选别的工具呢？”主要有两个原因。\n"),v("ul",[v("li",[_._v("第一个原因是 Antlr 能支持更广泛的目标语言，包括 Java、C#、JavaScript、Python、Go、C++、Swift。无论你用上面哪种语言，都可以用它生成词法和语法分析的功能。而我们就使用它生成了 Java 语言和 C++ 语言两个版本的代码")]),_._v(" "),v("li",[_._v("第二个原因是 Antlr 的语法更加简单。它能把类似左递归的一些常见难点在工具中解决，对提升工作效率有很大的帮助")])])])]),_._v(" "),v("h3",{attrs:{id:"antlr-工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#antlr-工具"}},[_._v("#")]),_._v(" Antlr 工具")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.antlr.org/",target:"_blank",rel:"noopener noreferrer"}},[_._v("下载 Antlr 工具"),v("OutboundLink")],1)]),_._v(" "),v("li",[_._v("Antlr 通过解析规则文件来生成编译器。规则文件以.g4 结尾，词法规则和语法规则可以放在同一个文件里。不过为了清晰起见")])]),_._v(" "),v("p",[_._v("既然用 Antlr 可以不管左递归问题，那之前为什么要费力气解决它呢？”那是因为当你遇到某些问题却没有现成工具时，还是要用纯手工的方法去解决问题。而且，有的工具可能没有这么智能，你需要写出符合这个工具的规则文件，比如说不能有左递归的语法规则。"),v("strong",[_._v("还是那句话：懂得基础原理，会让你站得更高。")])]),_._v(" "),v("h2",{attrs:{id:"⭐️编译器后端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️编译器后端"}},[_._v("#")]),_._v(" ⭐️编译器后端")]),_._v(" "),v("h2",{attrs:{id:"⭐️06丨实现一门编译型语言-·-原理篇-12讲"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️06丨实现一门编译型语言-·-原理篇-12讲"}},[_._v("#")]),_._v(" ⭐️06丨实现一门编译型语言 · 原理篇 (12讲)")]),_._v(" "),v("h2",{attrs:{id:"✔️20-高效运行-编译器的后端技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️20-高效运行-编译器的后端技术"}},[_._v("#")]),_._v(" ✔️20.高效运行：编译器的后端技术")]),_._v(" "),v("ul",[v("li",[_._v("前 18 节课，我们主要探讨了编译器的前端技术，它的重点，是让编译器能够读懂程序。无 结构的代码文本，经过前端的处理以后，就变成了 Token、AST 和语义属性、符号表等结 构化的信息\n"),v("ul",[v("li",[_._v("基于这些信息，我们可以实现简单的"),v("strong",[_._v("脚本解释器")])])])]),_._v(" "),v("li",[_._v("但很多情况下，我们需要继续把程序编译成"),v("strong",[_._v("机器能读懂的代码")]),_._v("，并高效运行。这时，我们就 面临了三个问题\n"),v("ul",[v("li",[_._v("1、我们必须了解计算机运行一个程序的原理（也就是"),v("strong",[_._v("运行期机制")]),_._v("），只有这样，才知道如 何生成这样的程序")]),_._v(" "),v("li",[_._v("2、要能利用前端生成的 AST 和属性信息，将其正确翻译成目标代码")]),_._v(" "),v("li",[_._v("3、需要对程序做尽可能多的优化，比如让程序执行效率更高，占空间更少等等。")])])])]),_._v(" "),v("h3",{attrs:{id:"_20-1-弄清程序的运行机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-1-弄清程序的运行机制"}},[_._v("#")]),_._v(" 20.1.弄清程序的运行机制")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210914183317.png",alt:"image-20210914183317469"}})]),_._v(" "),v("ul",[v("li",[_._v("一个是 CPU，它能接受机器指令和数据，并进行计算。它里面有寄存器、高速缓存和运算单元，充分利用寄存器和高速缓存会让系统的性能大大提升。")]),_._v(" "),v("li",[_._v("另一个是内存。我们要在内存里保存编译好的代码和数据，还要设计一套机制，让程序最高效地利用这些内存。")])]),_._v(" "),v("p",[_._v("通常情况下，我们的程序要受某个"),v("strong",[_._v("操作系统")]),_._v("的管理，所以也要符合操作系统的一些约定。但 "),v("strong",[_._v("有时候我们的程序也可能直接跑在硬件上")]),_._v("，"),v("strong",[_._v("单片机")]),_._v("和很多"),v("strong",[_._v("物联网设备")]),_._v("采用这样的结构，甚至一些服务端系统，也可以不跑在操作系统上。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("我会在下一节课，也就是21 讲，将运行期的机制讲清楚")]),_._v("，比如内存空间如何划分和组织；程序是如何启动、跳转和退出的；执行过程中指令和数据如何传递到 CPU；整个过 程中需要如何跟操作系统配合，等等")])]),_._v(" "),v("h3",{attrs:{id:"_20-2-生成代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-2-生成代码"}},[_._v("#")]),_._v(" 20.2.生成代码")]),_._v(" "),v("ul",[v("li",[_._v("编译器后端的最终结果，就是生成目标代码。\n"),v("ul",[v("li",[_._v("如果"),v("strong",[_._v("目标")]),_._v("是在"),v("strong",[_._v("计算机上直接运行")]),_._v("，就像 C 语 言程序那样，那"),v("font",{staticStyle:{background:"yellow"}},[_._v("这个"),v("strong",[_._v("目标代码")]),_._v("指的是"),v("strong",[_._v("汇编代码")]),_._v("。")])],1),_._v(" "),v("li",[_._v("而如果"),v("strong",[_._v("运行目标")]),_._v("是 "),v("strong",[_._v("Java 虚拟机")]),_._v("，那这个"),v("font",{staticStyle:{background:"yellow"}},[v("strong",[_._v("目标代码")]),_._v("就是指 "),v("strong",[_._v("JVM 的字节码")]),_._v("。")])],1)])]),_._v(" "),v("li",[v("font",{staticStyle:{background:"yellow"}},[_._v("基于我们在编译器前端所生成的成果，我们其实可以"),v("strong",[_._v("直接生成汇编代码")]),_._v("，在后面的课程中， 我会带你做一个这样的尝试。")])],1)]),_._v(" "),v("h4",{attrs:{id:"汇编代码定心剂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#汇编代码定心剂"}},[_._v("#")]),_._v(" 汇编代码定心剂")]),_._v(" "),v("ul",[v("li",[_._v("你可能惧怕汇编代码，觉得它肯定很难，能写汇编的人一定很牛。在我看来，这是一个偏 见，")]),_._v(" "),v("li",[_._v("因为汇编代码并不难写，为什么呢？")]),_._v(" "),v("li",[_._v("其实汇编没有类型，也没有那么多的语法结构，它要做的通常就是把数据拷贝到寄存器，处理一下，再保存回内存。所以，从汇编语言的特性看，就决定了它不可能复杂到哪儿去。\n"),v("ul",[v("li",[_._v("你如果问问硬件工程师就知道了，因为他们经常拿汇编语言"),v("strong",[_._v("操作寄存器、调用中断")]),_._v("，也没多难。")])])])]),_._v(" "),v("h4",{attrs:{id:"汇编详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#汇编详解"}},[_._v("#")]),_._v(" 汇编详解")]),_._v(" "),v("ul",[v("li",[_._v("当然，写汇编跟使用高级语言有很多不同，其中一点就是"),v("strong",[_._v("要关心 CPU 和内存这样具体的硬件")]),_._v("。\n"),v("ul",[v("li",[_._v("比如，你需要了解"),v("strong",[_._v("不同的 CPU 指令集的差别")])]),_._v(" "),v("li",[_._v("你还需要知道 "),v("strong",[_._v("CPU 是 64 位的还是 32 位的")])]),_._v(" "),v("li",[v("strong",[_._v("有几个寄存器")]),_._v("，"),v("strong",[_._v("每个寄存器可以用于什么指令")]),_._v("，等等。")]),_._v(" "),v("li",[_._v("但这样导致的问题是，每种语言，针对每种不同的硬件，都要生成不同的汇编代码。")])])])]),_._v(" "),v("p",[_._v("所以，为了降低后端工作量，提高软件复用度，就需要引入中间代码（Intermediate Representation，IR）的机制，它是独立于具体硬件的一种代码格式。")]),_._v(" "),v("h3",{attrs:{id:"_20-3-中间代码-intermediate-representation-ir-存在的必要性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-3-中间代码-intermediate-representation-ir-存在的必要性"}},[_._v("#")]),_._v(" 20.3.中间代码（Intermediate Representation，IR）存在的必要性")]),_._v(" "),v("ul",[v("li",[_._v("如果有 n 个前端语言，m 个后端架构，本来需要做 m*n 个翻译程序，现在只需要 m+n 个了。这就大大降低了总体 的工作量。")]),_._v(" "),v("li",[v("font",{staticStyle:{background:"yellow"}},[v("strong",[_._v("甚至，很多语言主要做好前端就行了")])]),_._v("，后端可以尽量重用已有的库和工具，这也是现在推出新语言越来越快的原因之一")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210909165828.png",alt:"image-20210909165828340"}})]),_._v(" "),v("h3",{attrs:{id:"⭐️各种ir格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️各种ir格式"}},[_._v("#")]),_._v(" ⭐️各种IR格式")]),_._v(" "),v("ul",[v("li",[_._v("IR 可以有多种格式，在第 24 讲，我们会介绍\n"),v("ul",[v("li",[v("strong",[_._v("三地址代码")])]),_._v(" "),v("li",[v("strong",[_._v("静态单赋值码")]),_._v("等不同的 IR。")]),_._v(" "),v("li",[_._v("Java 语言生成的"),v("strong",[_._v("字节码")]),_._v("也是一种 IR")]),_._v(" "),v("li",[_._v("我们还会介绍 "),v("strong",[_._v("LLVM 的 IR")]),_._v("，并且基于 LLVM 这个工具来加速我们后端的开发。")]),_._v(" "),v("li",[_._v("其实，IR 这个词直译成中文，是“"),v("strong",[_._v("中间表示方式")]),_._v("”的意思，不一定非是像汇编代码那样的 一条条的指令。所以，"),v("strong",[_._v("AST 其实也可以看做一种 IR")]),_._v("。我们在前端部分实现的脚本语言，就是基于 AST 这个 IR 来运行的")])])])]),_._v(" "),v("h4",{attrs:{id:"每种-ir-的目的和用途是不一样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#每种-ir-的目的和用途是不一样的"}},[_._v("#")]),_._v(" 每种 IR 的目的和用途是不一样的：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("AST")]),_._v(" 主要用于"),v("strong",[_._v("前端")]),_._v("的工作。")]),_._v(" "),v("li",[_._v("Java 的"),v("strong",[_._v("字节码")]),_._v("，是设计"),v("strong",[_._v("用来在虚拟机上运行")]),_._v("的。")]),_._v(" "),v("li",[v("strong",[_._v("LLVM 的中间代码，"),v("strong",[_._v("主要是用于做")]),_._v("代码翻译")]),_._v("和"),v("strong",[_._v("编译优化")]),_._v("的。")])]),_._v(" "),v("h3",{attrs:{id:"_20-4-代码分析和优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-4-代码分析和优化"}},[_._v("#")]),_._v(" 20.4.代码分析和优化")]),_._v(" "),v("ul",[v("li",[_._v("实际上，就算是现在常见的"),v("strong",[_._v("脚本语言")]),_._v("，如 Python 和 JavaScript，也"),v("strong",[_._v("做了很多后端优化的工作")]),_._v("，包括编译成字节码、支持即时编译等，这些都是为了进一步提高性能\n"),v("ul",[v("li",[_._v("从谷歌支持的 开源项目 V8 开始，JavaScript 的性能获得了巨大的提高，这才导致了 JavaScript 再一次 的繁荣，包括支持体验更好的前端应用和基于 Node.js 的后端应用。")])])])]),_._v(" "),v("h4",{attrs:{id:"优化工作又分为-独立于机器的优化-和-依赖于机器的优化-两种。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化工作又分为-独立于机器的优化-和-依赖于机器的优化-两种。"}},[_._v("#")]),_._v(" 优化工作又分为“独立于机器的优化”和“依赖于机器的优化”两种。")]),_._v(" "),v("h3",{attrs:{id:"_20-5-独立于机器的优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-5-独立于机器的优化"}},[_._v("#")]),_._v(" 20.5.独立于机器的优化?")]),_._v(" "),v("ul",[v("li",[v("font",{staticStyle:{background:"yellow"}},[_._v("独立于机器的优化，是基于 IR 进行的。")])],1),_._v(" "),v("li",[_._v("它可以通过对代码的分析，用更加高效的代码代替原来的代码。")]),_._v(" "),v("li",[v("strong",[_._v("计算机代码里有很多这种需要优化的情形")]),_._v("。我们在 "),v("strong",[_._v("27 和 28 讲")]),_._v("会介绍多种优化技术，\n"),v("ul",[v("li",[_._v("比如 局部优化和全局优化，")]),_._v(" "),v("li",[_._v("常数折叠、")]),_._v(" "),v("li",[_._v("拷贝传播、")]),_._v(" "),v("li",[_._v("删除公共子表达式等，其中"),v("strong",[_._v("数据流分析方法")]),_._v("比较重要，会重点介绍。")])])])]),_._v(" "),v("h3",{attrs:{id:"_20-6-依赖于机器的优化-则是依赖于硬件的特征"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-6-依赖于机器的优化-则是依赖于硬件的特征"}},[_._v("#")]),_._v(" 20.6.依赖于机器的优化，则是依赖于硬件的特征")]),_._v(" "),v("ul",[v("li",[_._v("依赖于机器的优化，则是依赖于硬件的特征.现代的计算机硬件设计了很多特性，以便提供 更高的处理能力，比如并行计算能力，多层次内存结构（使用多个级别的高速缓存）等等。 编译器要能够充分利用硬件提供的性能，比如\n"),v("ul",[v("li",[v("strong",[_._v("寄存器优化")]),_._v("。对于频繁访问的变量，最好放在寄存器中，并且尽量最大限度地利用寄存器，不让其中一些空着，有不少算法是解决这个问题的，"),v("strong",[_._v("教材上一般提到的是染色算法")])]),_._v(" "),v("li",[_._v("充分利用高速缓存。")]),_._v(" "),v("li",[v("strong",[_._v("并行性")]),_._v("。现代计算机都有多个内核，可以并行计算。我们的编译器要尽可能把充分利用多 个内核的计算能力。"),v("font",{staticStyle:{background:"yellow"}},[_._v(" 这在编译技术中是一个"),v("strong",[_._v("专门的领域")]),_._v("。")])],1),_._v(" "),v("li",[v("strong",[_._v("流水线")]),_._v("。CPU 在处理不同的指令的时候，需要等待的时间周期是不一样的，在等待某些指令做完的过程中其实还可以执行其他指令。")]),_._v(" "),v("li",[v("strong",[_._v("指令选择")]),_._v("。有的时候，"),v("strong",[_._v("CPU 完成一个功能，有多个指令可供选择")]),_._v("。而针对某个特定的需 求，采用 A 指令可能比 B 指令效率高百倍。比如 "),v("strong",[_._v("X86 架构的 CPU 提供 SIMD 功能，也 就是一条指令可以处理多条数据")]),_._v("，而不是像传统指令那样一条指令只能处理一条数据。在内存计算领域，SIMD 也可以大大提升性能，我们在第 30 讲的应用篇，会针对 SIMD 做 一个实验")]),_._v(" "),v("li",[_._v("其他优化。比如可以针对专用的 AI 芯片和 GPU 做优化，提供 AI 计算能力，等等")])])]),_._v(" "),v("li",[_._v("总结起来，在编译器中需要对代码进行的优化非常多。因此，这部分工作也是编译过程中耗 时最长、最体现某个编译器的功力的一类工作，所以更值得引起你的重视。")])]),_._v(" "),v("h3",{attrs:{id:"_20-7-展望编译器后端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-7-展望编译器后端"}},[_._v("#")]),_._v(" 20.7.展望编译器后端")]),_._v(" "),v("ul",[v("li",[_._v("刚接触编译技术的时候，你可能会把视线停留在前端技术上，以为能做 Lexer、Parser 就 是懂编译了。\n"),v("ul",[v("li",[_._v("实际上，词法分析和语法分析比较成熟，有成熟的工具来支撑。")])])]),_._v(" "),v("li",[v("strong",[_._v("相对来说，后 端的工作量更大，挑战更多，研究的热点也更多")]),_._v("。比如，人工智能领域又出现了一些专用的 AI 芯片和指令集，就需要去适配。")]),_._v(" "),v("li",[_._v("前端关注的是正确反映了代码含义的静态结构，而后端关注的是让代码良好运行的动态结构。\n"),v("ul",[v("li",[_._v("它们之间的差别，从我讲解“作用域”和“生存期”两个概念时就能看出来。\n"),v("ul",[v("li",[_._v("作用域是前端的概念")]),_._v(" "),v("li",[_._v("而生存期是后端的概念。")])])])])])]),_._v(" "),v("p",[_._v("其实在前面的课程中，我们已经涉及了少量的后端技术的概念，比如生存期、栈桢，因为我 们要让脚本语言运行起来。但这个运行环境比较简单，脚本的执行也是简单的基于 AST， 所以性能是比较低的。但在后端部分，我们会实现一门静态编译型的语言，因此会对对运行 期机制做更加深入的解读和实现。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("如果能把后端技术学好，你对计算机底层运行机制的理解会更上一层楼，也会成为一名底子更加扎实的软件工程师。")])]),_._v(" "),v("li",[_._v("我们说"),v("font",{staticStyle:{background:"yellow"}},[_._v("编译器后端的任务是让程序"),v("strong",[_._v("适配硬件")]),_._v("、高效运行")])],1)]),_._v(" "),v("h2",{attrs:{id:"✔️21-运行时机制-突破现象看本质-透过「语法」看运行时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️21-运行时机制-突破现象看本质-透过「语法」看运行时"}},[_._v("#")]),_._v(" ✔️21.运行时机制：突破现象看本质，透过「语法」看运行时")]),_._v(" "),v("ul",[v("li",[_._v("编译器的任务，是要生成能够在计算机上运行的代码，但要生成代码，我们必须对"),v("strong",[_._v("程序的运行环境")]),_._v("和"),v("strong",[_._v("运行机制")]),_._v("有比较透彻的了解。")])]),_._v(" "),v("p",[_._v("本节课，我会对计算机程序如何运行，做一个解密，话题分成两个部分：")]),_._v(" "),v("ul",[v("li",[_._v("1、了解"),v("strong",[_._v("程序运行的「环境」")]),_._v("，包括 CPU、内存和操作系统，探知它们跟程序到底有什么关系。")]),_._v(" "),v("li",[_._v("2、了解"),v("strong",[_._v("程序运行的「过程」")]),_._v("。比如，一个程序是怎么跑起来的，代码是怎样执行和跳转的，又是如何管理内存的。")])]),_._v(" "),v("h3",{attrs:{id:"_21-1-程序运行的「环境」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-1-程序运行的「环境」"}},[_._v("#")]),_._v(" 21.1.程序运行的「环境」")]),_._v(" "),v("ul",[v("li",[_._v("程序运行的过程中，主要是跟两个硬件（CPU 和内存）以及一个软件（操作系统）打交 道。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210914194240.png",alt:"image-20210914194240630"}})]),_._v(" "),v("ul",[v("li",[_._v("本质上，我们的程序只关心 CPU 和内存这两个硬件。")]),_._v(" "),v("li",[_._v("你可能说：“不对啊，计算机还有其 他硬件，比如显示器和硬盘啊。”但"),v("strong",[_._v("对我们的程序来说")]),_._v("，"),v("font",{staticStyle:{background:"yellow"}},[_._v("操作这些硬件，也只是"),v("strong",[_._v("执行某些特定的驱动代码")]),_._v("，"),v("strong",[_._v("跟执行其他代码并没有什么差异")])])],1)]),_._v(" "),v("h3",{attrs:{id:"⭐️工程建议-在写系统级的程序时-你要对各种-io-的时间有基本的概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️工程建议-在写系统级的程序时-你要对各种-io-的时间有基本的概念"}},[_._v("#")]),_._v(" ⭐️工程建议：在写系统级的程序时，你要对各种 IO 的时间有基本的概念")]),_._v(" "),v("ul",[v("li",[_._v("比如"),v("strong",[_._v("高速缓存")]),_._v("、 "),v("strong",[_._v("内存")]),_._v("、"),v("strong",[_._v("磁盘")]),_._v("、"),v("strong",[_._v("网络")]),_._v("的 IO 大致都是什么数量级的。")]),_._v(" "),v("li",[_._v("因为这都影响到系统的整体性能，也影响 到你如何做程序优化。如果你需要对程序做更多的优化，还需要了解更多的 CPU 运行机 制，包括流水线机制、并行机制等等，这里就不展开了")])]),_._v(" "),v("p",[_._v("对于这个内存，该怎么用呢？")]),_._v(" "),v("p",[_._v("本质上来说，你想怎么用就怎么用，并没有什么特别的限制。一个编译器的作者，可以决定 在哪儿放代码，在哪儿放数据，当然了，别的作者也可能采用其他的策略。")]),_._v(" "),v("ul",[v("li",[_._v("实际上，C 语言 和 Java 虚拟机对内存的管理和使用策略就是不同的。")]),_._v(" "),v("li",[_._v("尽管如此，"),v("strong",[_._v("大多数语言还是会采用一些通用的内存管理模式")]),_._v("。以 C 语言为例，会把内存划 分为代码区、静态数据区、栈和堆。")])]),_._v(" "),v("p",[_._v("一般来讲，代码区是在最低的地址区域，然后是静态数据区，然后是堆。而栈传统上是从高 地址向低地址延伸，栈的最顶部有一块区域，用来保存环境变量。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("代码区（也叫文本段）"),v("strong",[_._v("存放编译完成以后的")]),_._v("机器码")]),_._v("。这个内存区域是"),v("strong",[_._v("只读的")]),_._v("，"),v("strong",[_._v("不会再修改， 但也不绝对")]),_._v("。现代语言的运行时已经越来越动态化，除了保存机器码，"),v("strong",[_._v("还可以存放中间代码")]),_._v("，并且还可以在运行时把中间代码编译成机器码，写入代码区。")]),_._v(" "),v("li",[_._v("**静态数据区「包括data和bss」**保存程序中全局的变量和常量。它的地址在编译期就是确定的，在生成的代码里 直接使用这个地址就可以访问它们，它们的生存期是从程序启动一直到程序结束。它又可以 细分为 Data 和 BSS 两个段。Data 段中的变量是在编译期就初始化好的，直接从程序装在 进内存。BSS 段中是那些没有声明初始化值的变量，都会被初始化成 0。")]),_._v(" "),v("li",[_._v("而栈适合保存生存期比较短的数据，比如函数和方法里的本地变量。它们在进入某个作用域 的时候申请内存，退出这个作用域的时候就可以释放掉。")])]),_._v(" "),v("h3",{attrs:{id:"操作系统的角色"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的角色"}},[_._v("#")]),_._v(" 操作系统的角色")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("在存在操作系统的情况下")]),_._v("，因为很多进程共享计算机资源，所以就要遵循一些约定。这就仿 佛办公室是所有同事共享的，那么大家就都要"),v("strong",[_._v("遵守一些约定")]),_._v("，如果一个人大声喧哗，就会影 响到其他人。")]),_._v(" "),v("li",[_._v("程序需要遵守的约定包括：\n"),v("ul",[v("li",[_._v("程序文件的二进制格式约定，这样操作系统才能程序正确地加载进来，并为同一个程序的多个进程共享代码区。")]),_._v(" "),v("li",[_._v("在"),v("strong",[_._v("使用寄存器和栈的时候也要遵守一些约定")]),_._v("，便于操作系统"),v("strong",[_._v("在不同的进程之间切换")]),_._v("的时候、在做系统调用的时候，做好上下文的保护。")])])])]),_._v(" "),v("h3",{attrs:{id:"_21-2-程序运行的「过程」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-2-程序运行的「过程」"}},[_._v("#")]),_._v(" 21.2.程序运行的「过程」")]),_._v(" "),v("ul",[v("li",[_._v("首先，可运行的程序一般是由操作系统加载到内存的，并且定位到代码区里程序的入口开始 执行。比如，C 语言的 main 函数的第一行代码。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210914195701.png",alt:"image-20210914195701300"}})]),_._v(" "),v("ul",[v("li",[_._v("我们把每"),v("strong",[_._v("次调用一个函数")]),_._v("的过程，叫做一次"),v("strong",[_._v("活动（Activation）")]),_._v("。每个活动都对应一个活"),v("strong",[_._v("动记录（Activation Record）")]),_._v("，这个活动记录里有这个函数运行所需要的信息，比如参数、 返回值、本地变量等")]),_._v(" "),v("li",[_._v("目前我们用栈来管理内存，所以可以把活动记录等价于栈桢。"),v("strong",[_._v("栈桢是活动记录的实现方式，")])])]),_._v(" "),v("h4",{attrs:{id:"从全局角度看整个运行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从全局角度看整个运行过程"}},[_._v("#")]),_._v(" 从全局角度看整个运行过程")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210914195939.png",alt:"image-20210914195939089"}})]),_._v(" "),v("ul",[v("li",[v("p",[_._v("你可以看到，每个栈桢的长度是不一样的。 用到的参数和本地变量多，栈桢就要长一点。但是，"),v("strong",[_._v("栈桢的长度和结构是在编译期就能完全确定的")]),_._v("。这样就便于我们计算地址的偏移量，获取栈桢里某个数据。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("CPU")]),_._v(" 上运行程序的指令，运行过程中要用到寄存器、高速缓存来提高指令和数据的存取 效率。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("内存")]),_._v("可以划分成不同的区域保存代码、静态数据，并用栈和堆来存放运行时产生的动态数据。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("操作系统")]),_._v("会把物理的内存映射成进程的寻址空间，同一份代码会被映射进多个进程的内存 空间，操作系统的公共库也会被映射进进程的内存空间，操作系统还会自动维护栈")])])]),_._v(" "),v("p",[_._v("本节课，我概要地介绍了程序运行的环境和运行过程。"),v("strong",[_._v("常见的静态编译型的语言，比如 C 语言、Go 语言，差不多都是这个模式")])]),_._v(" "),v("h4",{attrs:{id:"汇编的坑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#汇编的坑"}},[_._v("#")]),_._v(" 汇编的坑")]),_._v(" "),v("ul",[v("li",[_._v("Q：有些汇编的语法和上面的是反着的，比如 指令：寄存器 ，源操作数/地址")]),_._v(" "),v("li",[_._v("作者回复: 是的。我们用的都是"),v("strong",[_._v("GNU汇编的语法")]),_._v("。第22讲正式讲汇编的时候特别做了说明。看看 是不是在21讲提到汇编时也注释一下。")])]),_._v(" "),v("h2",{attrs:{id:"_22-生成汇编代码-一-汇编语言其实不难学"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-生成汇编代码-一-汇编语言其实不难学"}},[_._v("#")]),_._v(" 22.生成汇编代码（一）：汇编语言其实不难学")]),_._v(" "),v("h2",{attrs:{id:"⭐️课程规定的汇编-gnu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️课程规定的汇编-gnu"}},[_._v("#")]),_._v(" ⭐️课程规定的汇编-GNU")]),_._v(" "),v("p",[v("font",{staticStyle:{background:"yellow"}},[_._v("课程用的是 GNU 汇编器")])],1),_._v(" "),v("ul",[v("li",[v("p",[_._v("敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语 言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。")])]),_._v(" "),v("li",[v("p",[_._v("对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210909170632.png",alt:"下载"}})]),_._v(" "),v("h3",{attrs:{id:"计算机的处理器架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机的处理器架构"}},[_._v("#")]),_._v(" 计算机的处理器架构")]),_._v(" "),v("p",[_._v("计算机的处理器有很多不同的架构，比如 x86-64、ARM、Power 等，每种处理器的指令集都不相同，那也就意味着汇编语言不同。我们目前用的电脑，CPU 一般是 x86-64 架构，是 64 位机。（如不做特别说明，本课程都是以 x86-64 架构作为例子的）")]),_._v(" "),v("h2",{attrs:{id:"_23-生成汇编代码-二-把脚本编译成可执行文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-生成汇编代码-二-把脚本编译成可执行文件"}},[_._v("#")]),_._v(" 23.生成汇编代码（二）：把脚本编译成可执行文件")]),_._v(" "),v("h2",{attrs:{id:"_24-中间代码-兼容不同的语言和硬件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-中间代码-兼容不同的语言和硬件"}},[_._v("#")]),_._v(" 24.中间代码：兼容不同的语言和硬件")]),_._v(" "),v("p",[v("strong",[_._v("LLVM 汇编码（LLVM Assembly），是 LLVM 的 IR")])]),_._v(" "),v("h2",{attrs:{id:"_25-后端技术的重用-llvm不仅仅让你高效"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-后端技术的重用-llvm不仅仅让你高效"}},[_._v("#")]),_._v(" 25.后端技术的重用：LLVM不仅仅让你高效")]),_._v(" "),v("h2",{attrs:{id:"_26-生成ir-实现静态编译的语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26-生成ir-实现静态编译的语言"}},[_._v("#")]),_._v(" 26.生成IR：实现静态编译的语言")]),_._v(" "),v("h2",{attrs:{id:"_27-代码优化-为什么你的代码比他的更高效"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-代码优化-为什么你的代码比他的更高效"}},[_._v("#")]),_._v(" 27.代码优化：为什么你的代码比他的更高效？")]),_._v(" "),v("h2",{attrs:{id:"_28-数据流分析-你写的程序-它更懂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-数据流分析-你写的程序-它更懂"}},[_._v("#")]),_._v(" 28.数据流分析：你写的程序，它更懂")]),_._v(" "),v("h2",{attrs:{id:"_29-目标代码的生成和优化-一-如何适应各种硬件架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_29-目标代码的生成和优化-一-如何适应各种硬件架构"}},[_._v("#")]),_._v(" 29.目标代码的生成和优化（一）：如何适应各种硬件架构？")]),_._v(" "),v("h2",{attrs:{id:"_30-目标代码的生成和优化-二-如何适应各种硬件架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_30-目标代码的生成和优化-二-如何适应各种硬件架构"}},[_._v("#")]),_._v(" 30.目标代码的生成和优化（二）：如何适应各种硬件架构？")]),_._v(" "),v("h2",{attrs:{id:"加餐-汇编代码编程与栈帧管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加餐-汇编代码编程与栈帧管理"}},[_._v("#")]),_._v(" 加餐.汇编代码编程与栈帧管理")]),_._v(" "),v("h2",{attrs:{id:"⭐️07丨实现一门编译型语言-·-应用篇-2讲"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️07丨实现一门编译型语言-·-应用篇-2讲"}},[_._v("#")]),_._v(" ⭐️07丨实现一门编译型语言 · 应用篇 (2讲)")]),_._v(" "),v("h2",{attrs:{id:"✔️31丨内存计算-对海量数据做计算-到底可以有多快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️31丨内存计算-对海量数据做计算-到底可以有多快"}},[_._v("#")]),_._v(" ✔️31丨内存计算：对海量数据做计算，到底可以有多快？")]),_._v(" "),v("ul",[v("li",[_._v("2019-11-04 宫文学")]),_._v(" "),v("li",[_._v("内存计算是"),v("strong",[_._v("近十几年")]),_._v("来，在"),v("strong",[_._v("数据库")]),_._v("和"),v("strong",[_._v("大数据领域")]),_._v("的一个热点。随着内存越来越便宜，CPU 的架构越来越先进，整个数据库都可以放在内存中，并通过 SIMD 和并行计算技术，来提 升数据处理的性能。")]),_._v(" "),v("li",[_._v("本节课所采用的 CPU，支持一类叫做**SIMD（Single Instruction Multiple Data）**的指 令，它的字面意思是："),v("strong",[_._v("单条指令能处理多个数据")]),_._v(" "),v("ul",[v("li",[_._v("相应的，你可以把每次只处理一个数据的 指令，叫做 SISD（Single Instruction Single Data）。")])])])]),_._v(" "),v("h3",{attrs:{id:"_31-1-标量计算和矢量计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-1-标量计算和矢量计算"}},[_._v("#")]),_._v(" 31.1.标量计算和矢量计算")]),_._v(" "),v("p",[_._v("这种一次只处理一个数据的计算，叫做"),v("strong",[_._v("标量计算")]),_._v("；一次可以同时处理多个数据的计算，叫做 "),v("strong",[_._v("矢量计算")]),_._v("。它在一个寄存器里可以并排摆下 4 个、8 个甚至更多标量，构成一个矢量。图 中 ymm 寄存器是 256 位的，可以支持同时做 4 个 64 位数的计算（xmm 寄存器是它的低 128 位）。")]),_._v(" "),v("ul",[v("li",[_._v("当时， 让计算机能够播放多媒体（比如播放视频），是一个巨大的进步。但"),v("strong",[_._v("播放视")]),_._v("频需要"),v("strong",[_._v("大量的浮 点计算")]),_._v("，依靠原来 CPU 的浮点运算功能并不够。")]),_._v(" "),v("li",[_._v("在"),v("strong",[_._v("商业")]),_._v("领域，"),v("strong",[_._v("数据库系统")]),_._v("会采用 "),v("strong",[_._v("SIMD")]),_._v(" 来快速处理海量的数据；")]),_._v(" "),v("li",[v("strong",[_._v("人工智能")]),_._v("领域，"),v("strong",[_._v("机器学习")]),_._v("需要消耗大量的"),v("strong",[_._v("计算量")]),_._v("，SIMD 指令可以提升机器学习的速 度。")]),_._v(" "),v("li",[_._v("你平常写的程序，"),v("strong",[_._v("编译器")]),_._v("也会优化成，"),v("strong",[_._v("尽量使用 SIMD 指令")]),_._v("来提高性能。")])]),_._v(" "),v("h3",{attrs:{id:"_31-2-演示一下如何使用-simd-指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-2-演示一下如何使用-simd-指令"}},[_._v("#")]),_._v(" 31.2.演示一下如何使用 SIMD 指令")]),_._v(" "),v("ul",[v("li",[_._v("与传统的数据处理技术做性能上的对比，并 探讨"),v("strong",[_._v("如何在编译器中生成 SIMD 指令")]),_._v("，这样你可以针对自己的项目充分发挥 SIMD 指令的 优势。")]),_._v(" "),v("li",[_._v("Intel 公司为 SIMD 指令提供了一个标准的库")]),_._v(" "),v("li",[_._v("矢量化功能可以一个指令当好几个用，但刚才编写的 SIMD 示例代码使用了特别的库，这 些库函数本身就是用嵌入式的汇编指令写的，所以，相当于我们直接使用了 SIMD 的指 令。")]),_._v(" "),v("li",[_._v("如果我们"),v("strong",[_._v("不调用这几个库")]),_._v("，直接做加减乘除运算，"),v("strong",[_._v("能否获得 SIMD 的好处呢")]),_._v("？也可以。"),v("font",{staticStyle:{background:"yellow"}},[v("strong",[_._v("不过要靠编译器的帮助，")])]),_._v("所以，接下来来看看 LLVM 是怎样帮我们使用 SIMD 指令的。")],1)]),_._v(" "),v("h3",{attrs:{id:"_31-3-llvm-的自动矢量化功能-auto-vectorization"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-3-llvm-的自动矢量化功能-auto-vectorization"}},[_._v("#")]),_._v(" 31.3.LLVM 的自动矢量化功能（Auto-Vectorization）")]),_._v(" "),v("ul",[v("li",[_._v("各个编译器都在自动矢量化功能上下了功夫，以 LLVM 为例，它支持循环的矢量化（Loop Vectorizer）和 SLP 矢量化功能。")]),_._v(" "),v("li",[_._v("clang你用不同的参数去生成汇编代码，结果会不一样：")])]),_._v(" "),v("div",{staticClass:"language-bash line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[_._v("clang "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-S")]),_._v(" loop.c "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-o")]),_._v(" loop-scalar.s\nclang "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-S")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-O2")]),_._v(" loop.c "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-o")]),_._v(" loop-O2.s\nclang "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-S")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-O2")]),_._v(" -fno-vectorize loop.c "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-o")]),_._v(" loop-O2-scalar.s\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("ul",[v("li",[_._v("编译程序会生成矢量和标量两个版本的目标代码，在运行时检测 nums1 和 nums2 是否重叠，从而判断是否跳转到矢量化的计算代码。从这里你也可以看出："),v("strong",[_._v("写编译器真的要 有工匠精神，要把各种可能性都想到。")])]),_._v(" "),v("li",[_._v("除了循环的矢量化器，LLVM 还有一个 "),v("strong",[_._v("SLP 矢量化器")]),_._v("，它能在做全局优化时，寻找可被矢量化的代码来做转换")])]),_._v(" "),v("h3",{attrs:{id:"_31-4-高速缓存和局部性「计算机的存储的时钟周期」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-4-高速缓存和局部性「计算机的存储的时钟周期」"}},[_._v("#")]),_._v(" 31.4.高速缓存和局部性「计算机的存储的时钟周期」")]),_._v(" "),v("ul",[v("li",[_._v("速度最快的是寄存器，通常在寄存器之间复制数据只需要 1 个时钟周期。")]),_._v(" "),v("li",[_._v("其次是高速缓存，它根据速度和容量分为多个层级，读取所花费的时间从几个时钟周期 到几十个时钟周期不等。")]),_._v(" "),v("li",[_._v("内存则要用上百到几百个时钟周期。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/20210914180810.png",alt:"image-20210914180810528"}})]),_._v(" "),v("ul",[v("li",[_._v("图中：灰色标的数据是 Intel 公司的 Ice Lake架构的 CPU 的数据")])]),_._v(" "),v("h4",{attrs:{id:"影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#影响"}},[_._v("#")]),_._v(" 影响")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("一般的计算机指令 1 到几个时钟周期就可以执行完毕")]),_._v("。所以，如果等待"),v("strong",[_._v("内存")]),_._v("中读取，获得数据的话，CPU 的性能可能只能发挥出 "),v("strong",[_._v("1%")]),_._v("。不过"),v("strong",[_._v("由于高速缓存")]),_._v("的存在，读取数据的平均时间会缩短到几个时钟周期，这样 CPU 的能力可以充分发挥出来。")]),_._v(" "),v("li",[_._v("所以，我在讲程序的"),v("strong",[_._v("运行时环境")]),_._v("的时候，让你关注 CPU 上两个重要的部件：\n"),v("ul",[v("li",[_._v("一个是"),v("strong",[_._v("寄存器")])]),_._v(" "),v("li",[_._v("另一个就是"),v("strong",[_._v("高速缓存。")])])])]),_._v(" "),v("li",[_._v("在代码里，我们会用到寄存器，并且还会用专门的"),v("strong",[_._v("寄存器分配的算法")]),_._v("来优化寄存器。可是"),v("strong",[_._v("对于高速缓存，我们没有办法直接控制")]),_._v("。")]),_._v(" "),v("li",[_._v("那我们有什么办法呢？答案是提高程序的局部性（locality）")])]),_._v(" "),v("p",[_._v("一是时间局部性。一个数据一旦被加载到高速缓存甚至寄存器，我们后序的代码都能集 中访问这个数据，别等着这个数据失效了再访问，那就又需要从低级别的存储中加载一 次。")]),_._v(" "),v("p",[_._v("第二个是空间局部性。当我们访问了一条数据之后，很可能马上访问跟这个数据挨着的 其他数据。CPU 在一次读入数据的时候，会把相邻的数据都加载到高速缓存，这样会增 加后面代码在高速缓存中命中的概率。")]),_._v(" "),v("h4",{attrs:{id:"提高局部性「编译管-」「程序员管-」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高局部性「编译管-」「程序员管-」"}},[_._v("#")]),_._v(" 提高局部性「编译管？」「程序员管？」")]),_._v(" "),v("p",[_._v("提高局部性这件事情，更多的是程序员的责任，编译器能做的事情不多。")]),_._v(" "),v("p",[_._v("不过，有一种"),v("strong",[_._v("编译优化技术")]),_._v("，叫做**循环互换优化（loop interchange optimization）**可以让程序更好地利用高速缓存和寄存器。")]),_._v(" "),v("ul",[v("li",[_._v("这样的话，"),v("strong",[_._v("可能就需要生成两套代码")]),_._v("，在"),v("strong",[_._v("运行时根据情况决定跳转到哪个代码块去执行")]),_._v("，这样会导致"),v("strong",[_._v("目标代码的膨胀")]),_._v("。「啊这。。。。这」")])]),_._v(" "),v("h3",{attrs:{id:"_31-5-llvm设计目标之一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-5-llvm设计目标之一"}},[_._v("#")]),_._v(" 31.5.LLVM设计目标之一")]),_._v(" "),v("ul",[v("li",[_._v("如果不想让代码膨胀，又能获得优化的目标代码，你可以尝试在运行时做"),v("strong",[_._v("动态的优化")]),_._v("（也就是"),v("strong",[_._v("动态编译")]),_._v("），这也是 LLVM 的设计目标之一")])]),_._v(" "),v("h3",{attrs:{id:"_31-6-促成内存计算发展的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-6-促成内存计算发展的原因"}},[_._v("#")]),_._v(" 31.6.促成内存计算发展的原因")]),_._v(" "),v("p",[_._v("最后，除了 SIMD 和数据局部性，促成内存计算这个领域发展的还有两个因素：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("多内核并行计算")]),_._v("。现在的 CPU 内核越来越多，特别是用于服务器的 CPU。多路 CPU 几十上百个内核，能够让单机处理能力再次提升几十，甚至上百倍。")]),_._v(" "),v("li",[v("strong",[_._v("内存越来越便宜")]),_._v("。在"),v("strong",[_._v("服务器")]),_._v("上配置几十个 G 的内存已经是常规配置，"),v("strong",[_._v("配置上 T 的内存， 也不罕见")]),_._v("。这使得大量与数据处理有关的工作，可以基于内存，而不是磁盘。除了要更 新数据，几乎可以不访问相对速度很低的磁盘。")])]),_._v(" "),v("h3",{attrs:{id:"_31-7-计算密集型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-7-计算密集型"}},[_._v("#")]),_._v(" 31.7.计算密集型")]),_._v(" "),v("ul",[v("li",[_._v("SIMD 是一种"),v("strong",[_._v("指令级并行技术")]),_._v("，它能够矢量化地一次计算多条数据，从而提升计算性 能，在"),v("strong",[_._v("计算密集型")]),_._v("的需求中，比如多媒体处理、海量数据处理、人工智能、游戏等领 域，你可以考虑充分利用 SIMD 技术")]),_._v(" "),v("li",[v("strong",[_._v("有时候，我们必须在运行期，根据一些数据来做优化")]),_._v("，生成更优的目标代码，在"),v("strong",[_._v("编译期 不可能做到尽善尽美。")])])]),_._v(" "),v("p",[_._v("我想强调的是，熟悉编译器的后端技术将会有利于你参与"),v("strong",[_._v("基础平台的研发")]),_._v("。如果你想设计一 款内存数据库产品，一款大数据产品，或者其他产品，将计算机的底层架构知识，和编译技 术结合起来，会让你有机会发挥更大的作用！")]),_._v(" "),v("h2",{attrs:{id:"❎32丨字节码生成-为什么spring技术很强大"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#❎32丨字节码生成-为什么spring技术很强大"}},[_._v("#")]),_._v(" ❎32丨字节码生成：为什么Spring技术很强大？")]),_._v(" "),v("ul",[v("li",[_._v("Java 程序员几乎都了解 Spring。它的 **IoC（依赖反转）**和 **AOP（面向切面编程）**功能非常强大、易用。而它背后的字节码生成技术（在运行时，根据需要修改和生成 Java 字节码的技术）就是就是一项重要的支撑技术。")])]),_._v(" "),v("h3",{attrs:{id:"_32-5-展望一下量子计算机的面世和普及"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_32-5-展望一下量子计算机的面世和普及"}},[_._v("#")]),_._v(" 32.5.展望一下量子计算机的面世和普及？")]),_._v(" "),v("ul",[v("li",[_._v("Q：们展望一下量子计算机的面世和普及，会给编译器、操作系统、网络等传 统计算机技术带来什么样的冲击？会不会完全是另外一套技术栈？")]),_._v(" "),v("li",[_._v("A : "),v("strong",[_._v("答案是肯定的")]),_._v("。因为编译器、操作系统，都是跟"),v("strong",[_._v("底层架构关系密切")]),_._v("。我们目前用的编译器和操作系统的基本架构，跟50年前没有太大区别，原因就是计算机的基础架构没有改变")])]),_._v(" "),v("h2",{attrs:{id:"⭐️08丨实现一门编译型语言-·-扩展篇-3讲"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️08丨实现一门编译型语言-·-扩展篇-3讲"}},[_._v("#")]),_._v(" ⭐️08丨实现一门编译型语言 · 扩展篇 (3讲)")]),_._v(" "),v("h2",{attrs:{id:"_33-垃圾收集-能否不停下整个世界"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_33-垃圾收集-能否不停下整个世界"}},[_._v("#")]),_._v(" 33.垃圾收集：能否不停下整个世界？")]),_._v(" "),v("h2",{attrs:{id:"_34-运行时优化-即时编译的原理和作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_34-运行时优化-即时编译的原理和作用"}},[_._v("#")]),_._v(" 34.运行时优化：即时编译的原理和作用")]),_._v(" "),v("h2",{attrs:{id:"_35-案例总结与热点问题答疑-后端部分真的比前端部分难吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_35-案例总结与热点问题答疑-后端部分真的比前端部分难吗"}},[_._v("#")]),_._v(" 35.案例总结与热点问题答疑：后端部分真的比前端部分难吗？")]),_._v(" "),v("h2",{attrs:{id:"⭐️09丨面向未来的编程语言-3讲"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#⭐️09丨面向未来的编程语言-3讲"}},[_._v("#")]),_._v(" ⭐️09丨面向未来的编程语言 (3讲)")]),_._v(" "),v("h2",{attrs:{id:"_36-当前技术的发展趋势以及其对编译技术的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_36-当前技术的发展趋势以及其对编译技术的影响"}},[_._v("#")]),_._v(" 36.当前技术的发展趋势以及其对编译技术的影响")]),_._v(" "),v("p",[_._v("本节课，我想与你分享 3 个方面的技术发展趋势，以及它们对编译技术的影响")]),_._v(" "),v("ul",[v("li",[_._v("人工智能，以及如何让编程和编译技术变得更智能？")]),_._v(" "),v("li",[_._v("云计算，以及是否需要云原生的语言？")]),_._v(" "),v("li",[_._v("前端技术，以及能否出现统一各个平台的大前端技术？")])]),_._v(" "),v("h3",{attrs:{id:"趋势1-让编程更智能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#趋势1-让编程更智能"}},[_._v("#")]),_._v(" 趋势1：让编程更智能")]),_._v(" "),v("p",[_._v("首先，它需要编译器能够支撑，机器学习对庞大计算力的需求，同时兼容越来越多新的硬件 架构")]),_._v(" "),v("p",[_._v("由于机器学习的过程需要大量的计算，仅仅采用 CPU 效率很低，所以 "),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[_._v("GPU"),v("OutboundLink")],1),_._v(" 和 "),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BC%A0%E9%87%8F%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83",target:"_blank",rel:"noopener noreferrer"}},[_._v("TPU"),v("OutboundLink")],1),_._v(" 等新的 硬件架构得到了迅速的发展。对于编译技术来说，首要的任务，是要充分发挥这些新硬件的 能力；因为 AI 的算法要能跑在各种后端架构上，包括 CPU、GPU 和 TPU，也包括仍然要 采用 SIMD 等技术，所以后端技术就会变得比较复杂")]),_._v(" "),v("ul",[v("li",[_._v("同时，前端也有不同的技术框架， 人工智能，以及如何让编程和编译技术变得更智能？ 云计算，以及是否需要云原生的语言？ 前端技术，以及能否出现统一各个平台的大前端技术？ 比如谷歌的 TensorFlow、Facebooke 的 pyTorch 等。那么编译器怎样更好地支持多种前 端和多种后端呢？")])]),_._v(" "),v("p",[v("strong",[_._v("张量处理单元")]),_._v("（英文："),v("strong",[_._v("Tensor Processing Unit，"),v("strong",[_._v("简称：TPU），也称")]),_._v("张量处理器")])]),_._v(" "),v("p",[v("strong",[_._v("图形处理器")]),_._v("（英语："),v("strong",[_._v("G")]),_._v("raphics "),v("strong",[_._v("P")]),_._v("rocessing "),v("strong",[_._v("U")]),_._v("nit，缩写："),v("strong",[_._v("GPU")]),_._v("；又称"),v("strong",[_._v("显示核心")]),_._v("、"),v("strong",[_._v("显卡")]),_._v("、"),v("strong",[_._v("视觉处理器")]),_._v("、"),v("strong",[_._v("显示芯片")]),_._v("或"),v("strong",[_._v("绘图芯片")]),_._v("）")]),_._v(" "),v("p",[_._v("比如说，"),v("strong",[_._v("在后端技术部分，很多算法都是 NP 完全的")]),_._v("。这就是说，如果你用穷举的方法找 出最优解，成本非常高。这个时候，就会用启发式（heuristic）的算法，也就是凭借直观 或经验构造的算法，能够在可接受的花费下找出一个可行的解。那么采用人工智能技术，通 过大数据的训练，有可能找出更好的启发式算法，供我们选择。这是人工智能和编译技术结 合的一个方向。")]),_._v(" "),v("p",[v("strong",[_._v("我建议你了解，编译技术和人工智能这两个领域的知识。那些计算机的基础知识会一直有用")]),_._v("，你可以参与到编程范式迁移，这样一个伟大的进程中。现有程序开发中的那些简单枯 燥，又不需要多少创造力的工作，也就是大家通常所说的“搬砖”工作，可能会被 AI 代 替。")]),_._v(" "),v("h3",{attrs:{id:"而我猜测-未来的机会可能会留给两类人"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#而我猜测-未来的机会可能会留给两类人"}},[_._v("#")]),_._v(" 而我猜测，未来的机会可能会留给两类人：")]),_._v(" "),v("ul",[v("li",[_._v("一类是具备更加深入的计算机基础技能，能应对未来挑战的，计算机技术人才，他们为 新的计算基础设施的发展演化，贡献自己的力量。")]),_._v(" "),v("li",[_._v("另一类是应用领域的专家和人才。他们通过更富有创造力的工作，利用新的编程技术实 现各种应用。编写应用程序的重点，可能不再是写代码，而是通过人工智能，训练出能 够反映领域特点的模型")])]),_._v(" "),v("h3",{attrs:{id:"趋势-2-云原生的开发语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#趋势-2-云原生的开发语言"}},[_._v("#")]),_._v(" 趋势 2：云原生的开发语言")]),_._v(" "),v("ul",[v("li",[_._v("云计算技术现在的普及度很广，所有应用的后端部分，缺省情况下都是跑在云平台上的，云 就是应用的运行环境。")]),_._v(" "),v("li",[_._v("而在云环境下，软件模块以服务的形式存在，也就是说，一个模块通过 RESTful 接口或各种 RPC 协议，调用另外的模块的功能。程序还需要处理通讯失败的情 况，甚至要在调用多个微服务时，保证分布式事务特性。而我们却没从编译技术的角度，帮 助程序员减轻这个负担。")]),_._v(" "),v("li",[_._v("导致的结果是：现在后端的程序特别复杂。你要写很多代码，来处理 RPC、消息、分布式 事务、数据库分片等逻辑，还要跟各种库、框架、通讯协议等等打交道。更糟糕的是，这些 技术性的逻辑跟应用逻辑，混杂在一起，让系统的复杂度迅速提高，开发成本迅速提升，维 护难度也增加。很多试图采用微服务架构的项目因此受到挫折，甚至回到单一应用的架构。")]),_._v(" "),v("li",[_._v("所以，一个有意义的问题是：能否在语言设计的时候，就充分利用云的基础设施，实现云原 生（Cloud Native）的应用？")])]),_._v(" "),v("h3",{attrs:{id:"趋势-3-大前端技术栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#趋势-3-大前端技术栈"}},[_._v("#")]),_._v(" 趋势 3：大前端技术栈")]),_._v(" "),v("ul",[v("li",[_._v("上面所讲的云计算，针对的是后端编程，而与此对应的，是前端编程工作。\n"),v("ul",[v("li",[_._v("后端工作的特点，是越来越云化，让工程师们头疼的问题，是处理分布式计算环境下，软件 系统的复杂性。当然，前端的挑战也不少。")])])]),_._v(" "),v("li",[_._v("我们开发一款应用，通常需要支持 Web、IOS 和 Android 三种平台，有时候，甚至需要提 供 Windows 和 macOS 的桌面客户端。不同的平台会需要不同的技术栈，从而导致一款应 用的开发成本很高，这也是前端工程师们不太满意的地方.所以，前端工程师们一直希望能用一套技术栈，搞定多个平台。比如，尝试用 Web 开发的 技术栈完成 Android、IOS 和桌面应用的开发。React Native、Electron 等框架是这个方 面的有益探索；Flutter 项目也做了一些更大胆的尝试。")]),_._v(" "),v("li",[v("font",{staticStyle:{background:"yellow"}},[_._v("你可以把这种技术思路叫做"),v("strong",[_._v("大前端")]),_._v("：同一套代码，支持多个平台。")])],1)]),_._v(" "),v("p",[_._v("当然，编译技术还有很多其他的研究方向，比如更好地支持"),v("strong",[_._v("并行计算")]),_._v("、"),v("strong",[_._v("支持物联网")]),_._v("和"),v("strong",[_._v("低功耗 场景")]),_._v("，支持"),v("strong",[_._v("区块链")]),_._v("，甚至支持一些同学感兴趣的，未来的量子计算机，等等。不过，在我看 来，我在文中提到的这三个趋势，跟你的关系是最为密切的。因为你现在或多或少地都在接 触 AI、云和前端技术。")]),_._v(" "),v("h2",{attrs:{id:"_37-云编程-云计算会如何改变编程模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_37-云编程-云计算会如何改变编程模式"}},[_._v("#")]),_._v(" 37.云编程：云计算会如何改变编程模式？")]),_._v(" "),v("p",[_._v("总的来说，现在编写程序是越来越云化了，所以，我们简单地称作"),v("strong",[_._v("云编程")]),_._v("就好了")]),_._v(" "),v("ul",[v("li",[_._v("喜欢编程的人，为了获得流畅的性能，电脑配置总是很高，虽然这足以满足 C/C++ 时代的 编程需要，")]),_._v(" "),v("li",[_._v("但进入 Java 时代后，因为应用结构越来越复杂，工程师们有时需要在笔记本或 桌面电脑上，安装各种复杂的中间件，甚至还要安装数据库软件，这时，电脑的配置即便再 高，也很难安装和配置好这么复杂的环境。")]),_._v(" "),v("li",[_._v("那么到了云计算时代，挑战就更大了，比如，你 能想象在电脑上安装 Hadoop 等软件，来做大数据功能的开发吗？")])]),_._v(" "),v("p",[_._v("因此，工程师们"),v("strong",[_._v("已经习惯于，在云上搭建开发和测试环境，这样，可以随需获取各种云端资源")]),_._v("。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("无服务器（Serverless）架构，或者叫做 FaaS（Function as a Service）")]),_._v("，做了进一步 的抽象。你只要把一个个功能写成函数，就能被平台调用，来完成 Web 服务、消息队列处 理等工作。这些函数可能是运行在容器中的，通过 Kubernetes 管理的，并且按照一定的 架构来协调各种服务功能")])]),_._v(" "),v("h2",{attrs:{id:"_38-元编程-一边写程序-一边写语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_38-元编程-一边写程序-一边写语言"}},[_._v("#")]),_._v(" 38.元编程：一边写程序，一边写语言")]),_._v(" "),v("ul",[v("li",[_._v("今天，我再带你讨论一个很有趣的话题：元编程。把这个话题放在这一篇的压轴位置，也暗 示了这个话题的重要性。")]),_._v(" "),v("li",[_._v("元编程（Meta Programming）")])]),_._v(" "),v("p",[_._v("元编程是这样一种技术："),v("font",{staticStyle:{background:"yellow"}},[_._v("你可以让计算机程序来操纵程序，也就是说，用程序修改或生成程序。")]),_._v("另一种说法是，具有元编程能力的语言，能够"),v("strong",[_._v("把程序当做数据来处理")]),_._v("，从而让程序产生 程序。")],1),_._v(" "),v("blockquote",[v("p",[_._v("哈哈，但是："),v("font",{staticStyle:{background:"yellow"}},[_._v("你学过编译原理就知道，在 CPU 眼里，程序本来就是数据")])],1)]),_._v(" "),v("ul",[v("li",[_._v("而元编程也有"),v("strong",[_._v("传统编程")]),_._v("所不具备的好处：比如，可以用更简单的编码来实现某个功能，以及 可以按需产生、完成某个功能的代码，从而让系统更有灵活性")]),_._v(" "),v("li",[_._v("某种意义上，元编程让程序员拥有了语言设计者的一些权力。是不是很酷？你甚至可以说， 普通程序员自己写程序，文艺程序员让程序写程序。「2333，离谱」")]),_._v(" "),v("li",[_._v("那么本节课，我会带你通过实际的例子，详细地来理解什么是元编程，然后"),v("strong",[_._v("探讨带有元编程 能力的语言的特性")]),_._v("，以及与编译技术的关系。通过这样的讨论，我希望你能理解元编程的思维，并利用"),v("strong",[_._v("编译技术")]),_._v("和"),v("strong",[_._v("元编程")]),_._v("的思维，提升自己的编程水平。")])]),_._v(" "),v("p",[_._v("学 习编译原理的人，某种意义上都是语言的设计者。而"),v("strong",[_._v("元编程，也是让程序员具有语言设计者 的能力")]),_._v("。所以，你可以利用自己关于编译的知识，来深入掌握自己所采用的语言的元编程能 力。")]),_._v(" "),v("h2",{attrs:{id:"✔️结束语-用程序语言-推动这个世界的演化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️结束语-用程序语言-推动这个世界的演化"}},[_._v("#")]),_._v(" ✔️结束语 | 用程序语言，推动这个世界的演化")]),_._v(" "),v("ul",[v("li",[_._v("学习技术的过程，是跟大师对话的过程，是融入科技发展这条历史河流的过程，是一个有温 度的心路历程。 有同学在留言区说，这门课，串联了计算机领域的很多基础课程。的确如他所说，当然，我也认为编译原理这门课，串联着整个计算机发展的历史，以及做出重要贡献的一代代大师。")]),_._v(" "),v("li",[_._v("据说，张小龙曾经说过，读懂了《"),v("a",{attrs:{href:"https://book.douban.com/subject/5375620/",target:"_blank",rel:"noopener noreferrer"}},[_._v("失控"),v("OutboundLink")],1),_._v("》这本书的人，可以直接去他的团队上班。我猜，他 对复杂系统科学情有独钟，产生了很多的心得。而任正非先生则对热力学中熵的理论感触很 深，并把它深刻地融入到了华为的价值观和管理体系中。")]),_._v(" "),v("li",[_._v("感谢 Antlr 工具的作者特恩斯·帕尔（Terence Parr）以及")]),_._v(" "),v("li",[_._v("LLVM 的核心作者 克里斯·拉特纳（Chris Lattner）")])]),_._v(" "),v("h2",{attrs:{id:"✔️faq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#✔️faq"}},[_._v("#")]),_._v(" ✔️FAQ")]),_._v(" "),v("ul",[v("li",[_._v("19 | 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？")])]),_._v(" "),v("h3",{attrs:{id:"_01-问题一-对于左递归的语法-为什么我的推导不是左递归的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_01-问题一-对于左递归的语法-为什么我的推导不是左递归的"}},[_._v("#")]),_._v(" 01.问题一：对于左递归的语法，为什么我的推导不是左递归的？")]),_._v(" "),v("ul",[v("li",[_._v("这个问题本身反映了，进行递归下降分析的时候，如何保持清晰的思路")]),_._v(" "),v("li",[_._v("任何自顶向下的算法，都是在一个大的图里找到一条搜索路径的过程。最后的结果，是经过多次推导，生成跟输入的 Token 串相同的结果，解析完毕以后，所有 Token 也耗光。")])]),_._v(" "),v("h3",{attrs:{id:"_02-问题二-二元表达式的结合性的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_02-问题二-二元表达式的结合性的实现"}},[_._v("#")]),_._v(" 02.问题二：二元表达式的结合性的实现")]),_._v(" "),v("h3",{attrs:{id:"_03-问题三-二义性文法为什么也能正常解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_03-问题三-二义性文法为什么也能正常解析"}},[_._v("#")]),_._v(" 03.问题三 ：二义性文法为什么也能正常解析？")]),_._v(" "),v("h3",{attrs:{id:"_04-问题四-语法-和-文法-有什么区别和联系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_04-问题四-语法-和-文法-有什么区别和联系"}},[_._v("#")]),_._v(" 04.问题四：“语法”和“文法”有什么区别和联系？")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("文法（Grammar）")]),_._v("，是"),v("font",{staticStyle:{background:"yellow"}},[_._v("形式语言（Formal Language）")]),_._v("的一个术语。所以也有 Formal Grammar 这样的说法。这里的文法是定义清晰的规则，比如，我们的词法规则、语法规则和属性规则，都是用形式文法来定义的。\n"),v("ul",[v("li",[_._v("我们的课程里讲解了正则文法 (Regular Grammar)")]),_._v(" "),v("li",[_._v("上下文无关文法 (Context-free Grammar) 等不同的文法规则，用来描述词法和语法")])])],1),_._v(" "),v("li",[_._v("语法分析中的"),v("strong",[_._v("语法（Syntax）")]),_._v("，主要是描述词是怎么组成句子的，一个语言的语法规则，通常指的是这个 Syntax。")]),_._v(" "),v("li",[_._v("问题是，"),v("font",{staticStyle:{background:"yellow"}},[_._v("Grammar 这个词，在中文很多应用场景中也叫做语法。这是会"),v("strong",[_._v("引起混淆")]),_._v("的地方。我们在使用的时候要小心一点儿就行了")]),_._v("。")],1),_._v(" "),v("li",[_._v("比如，我做了一个规则文件，里面都是一些"),v("strong",[_._v("词法规则（Lexer Grammar）")]),_._v("，我会说，这是一个词法规则文件，或者"),v("strong",[_._v("词法文法")]),_._v("文件。这个时候，把它说成是一个语法规则文件，就有点儿含义模糊。因为这里面并没有语法规则（Syntax Grammar）。")])]),_._v(" "),v("h3",{attrs:{id:"_05-正则文法-正则表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_05-正则文法-正则表达式"}},[_._v("#")]),_._v(" 05.正则文法+正则表达式")]),_._v(" "),v("ul",[v("li",[_._v("符合"),v("strong",[_._v("正则文法")]),_._v("的表达式称为“"),v("strong",[_._v("正则表达式")]),_._v("”。生成工具 可以读入正则表达式，生成"),v("strong",[_._v("一种叫“有限自动机”的算法")]),_._v("，来完成具体的词法分析工作。")]),_._v(" "),v("li",[_._v("不要被“正则文法”和“有限自动机”吓到。正则文法是一种最普通、最常见的规则，写正则表达式的时候用的就是正则文法。")])]),_._v(" "),v("h3",{attrs:{id:"_06-antlr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_06-antlr"}},[_._v("#")]),_._v(" 06.ANTLR")]),_._v(" "),v("blockquote",[v("p",[_._v("维基百科："),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/ANTLR",target:"_blank",rel:"noopener noreferrer"}},[_._v("ANTLR"),v("OutboundLink")],1)])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("ANTLR")]),_._v("（全名："),v("strong",[_._v("AN")]),_._v("other "),v("strong",[_._v("T")]),_._v("ool for "),v("strong",[_._v("L")]),_._v("anguage "),v("strong",[_._v("R")]),_._v("ecognition）是基于LL(*)算法实现的语法解析器生成器（parser generator），用"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Java",target:"_blank",rel:"noopener noreferrer"}},[_._v("Java"),v("OutboundLink")],1),_._v("语言编写，使用自上而下（top-down）的递归下降"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/LL%E5%89%96%E6%9E%90%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[_._v("LL剖析器"),v("OutboundLink")],1),_._v("方法。")]),_._v(" "),v("li",[_._v("Antlr 是一个开源的工具，支持根据规则文件生成词法分析器和语法分析器，它自身是用 Java 实现的。")])]),_._v(" "),v("h3",{attrs:{id:"_07-llvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_07-llvm"}},[_._v("#")]),_._v(" 07.LLVM")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("维基百科："),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/LLVM",target:"_blank",rel:"noopener noreferrer"}},[_._v("LLVM"),v("OutboundLink")],1)])]),_._v(" "),v("li",[v("p",[_._v("业绩产品：中端优化")])])]),_._v(" "),v("h2",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),v("ul",[v("li",[_._v("编译原理之美，极客时间，宫文学")])])])}),[],!1,null,null,null);v.default=a.exports}}]);